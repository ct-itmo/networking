{% extends "chapter.html" %}
{% set ace_modes = ["sh"] %}
{% block chapter %}
{% set meta = user.docker_meta %}

{% macro check_button(task_name) %}
{% set meta = user.docker_meta %}
{% if not tasks[task_name].is_solved %}
{% if meta is not none and meta.state.name == 'READY' and meta.chapter == chapter.slug %}
    <form method="POST" action="{{ url_for("networking:firewall:check") }}">
        <input type="hidden" name="check" value="{{ task_name }}" />
        <p><button>Проверить</button></p>
    </form>
{% elif meta is not none and meta.chapter != chapter.slug %}
    <p>Чтобы запустить проверку, активируйте задание.</p>
{% else %}
    <p>Сейчас идёт активация или проверка задания. Пожалуйста, подождите.</p>
{% endif %}
{% endif %}
{% endmacro %}


<p>Дедлайн — <strong>TBA</strong>, 23:59 МСК. После этого задания будут стоить на четверть дешевле.</p>

<p>
    В этом задании у нас есть две независимых сети на уровне L2 (то есть два отдельных свитча с разными устройствами).
    Далее, мы будем называть эти сети <code>сеть A</code> и <code>сеть B</code>.
</p>
<ul>
    <li><code>Сеть A</code> &mdash; <code>{{ variant.ip4_a_network }}</code>;</li>
    <li><code>Сеть B</code> &mdash; <code>{{ variant.ip4_b_network }}</code>.</li>
</ul>

<p>
    Вам предстоит подключить ваше устройство в две сети и настроить его так, чтобы оно пересылало некоторые IP пакеты из одной сети в другую, то есть выполняло функции файрвола.
    Этому устройству нужно будет установить IP адреса <code>{{ variant.ip4_a_firewall }}</code> и <code>{{ variant.ip4_b_firewall }}</code> на соответствующих интерфейсах.
    Устройства в сети будут считать эти адреса гейтвеем и слать туда все IP пакеты по умолчанию.
</p>

<p>
    Для целей самостоятельного тестировая вы можете подключать в сети своих устройства.
    Мы гарантируем, что адреса <code>{{ variant.ip4_a_free }}</code> и <code>{{ variant.ip4_b_free }}</code> не будут заняты другими устройствами.
    Также есть несколько устройств, которые подключены постоянно, и вы можете их пинговать, чтобы проверить корректность настройки сетей.
    В <code>сети A</code> такое устройство имеет IP <code>{{ variant.ip4_a_client }}</code>, в <code>сети B</code> &mdash; <code>{{ variant.ip4_b_client }}</code>.
</p>

<h3>Часть 1. Две сети</h3>

<p>
    Для выполнения этого задания вам понадобится поддерживать два VPN подключения, эмулирующих подключение к двум независимым свичам.
    Подключение выполняется через один и тот же VPN конфиг, однако при подключении нужно будет задать название сети, которой вы хотите подключиться, через переменную <code>UV_NETWORK</code>.
    Наши сети имею название <code>internalA</code> и <code>internalB</code>.
</p>
<details>
<summary>Пример команд для подключения в Linux</summary>
<pre><code>sudo openvpn --config config-linux.ovpn --setenv UV_NETWORK internalA
sudo openvpn --config config-linux.ovpn --setenv UV_NETWORK internalB</code></pre>

<p>
    К командам можно добавить опцию <code>--daemon</code>, чтобы подключение происходило в фоновом режиме.
</p>
</details>


<p>
    Подключите свое устройство к сети и установите необходимые ip адреса.
    При желании, вы можете самостоятельно проверить, подключив еще одно свое устройство в какую-нибудь из сетей.
</p>

<p>
    Автоматическая проверка ниже подключит в <code>сеть B</code> еще одно устройство и попытается пропинговать ваш сервер и несколько других наших устройств.
    Чекпоинт будет пройден, если ваш сервер имеет в <code>сети B</code> IP адрес <code>{{ variant.ip4_b_firewall }}</code> и не имеет адрес <code>{{ variant.ip4_a_firewall }}</code>.
</p>

{{ checkpoint(tasks.setup) }}
{{ check_button("setup") }}
{{ check_log(logs.setup) }}

<p>
    А теперь давайте позволим устройствам из разых сетей общаться друг с другом.
    Для этого включите перенаправления трафика (forwarding) на вашем устройстве-файрволе.
</p>
<p><strong>Примечание:</strong> если раньше игрались с форвардингом проверьче, что у вас разрешен форфардинг ICMP, TCP и UDP пакетов между сетями <code>tap0</code> и <code>tap1</code>.</p>

<p>Чтобы проверить, что форвардинг работает в обще стороны, два наших бота пошлют несколько пакетов из одной сети в другую.
Если все хорошо, то вы закроете еще два чекпоинта.</p>

{{ checkpoint(tasks.forward_a_to_b) }}
{{ check_button("forward_a_to_b") }}
{{ check_log(logs.forward_a_to_b) }}

{{ checkpoint(tasks.forward_b_to_a) }}
{{ check_button("forward_b_to_a") }}
{{ check_log(logs.forward_b_to_a) }}


<h3>Часть 2. Сетевые огрничения</h3>

<p>Если вы просто включили пересылку пакетов в предыдущем задани, то вы неявно позволили устройствам обеих сетей слать пакеты в интернет.
    Поскольку у нас пока не настроен NAT, то пользы от этого не очень много: ответ на UDP пакет не дойдет, а TCP соединение установить не получится.
</p>

<p>Тем не менее, давайте ограничим сети и запретим слать пакеты любым хостам вне наших приватных сетей.</p>

<p>Теперь давайте дополнительно ограничим нашу <code>сеть B</code>.
    Для этого запретите установку TCP соединений из <code>сети B</code> в <code>сеть A</code>.
    При этом у устройств <code>сети A</code> все еще должна быть возможность открывать соединения в <code>сеть B</code>.
</p>

{{ checkpoint(tasks.tcp_unidirectional) }}
{{ check_button("tcp_unidirectional") }}
{{ check_log(logs.tcp_unidirectional) }}

<p>В <code>сети B</code> есть очень уязвимое устройство, которое имеет ip <code>{{ variant.ip4_b_client2 }}</code>.
Защитите его и запретите пересылку UDP пакетов на все порты, кроме <code>3001</code> и <code>{{ variant.allow_udp_port2 }}</code>.</p>

{{ checkpoint(tasks.udp_ports) }}
{{ check_button("udp_ports") }}
{{ check_log(logs.udp_ports) }}

<p>Иногда из <code>сети A</code> в <code>сеть B</code> приходят TCP-фреймы с вредным содержимым.
Известно, что внутри таких фреймов содержится фраза <code>{{ variant.tcp_bad_word }}</code>. Запретите все такие пакеты.
</p>

{{ checkpoint(tasks.tcp_body_filter) }}
{{ check_button("tcp_body_filter") }}
{{ check_log(logs.tcp_body_filter) }}


<h3>Часть 3. NAT</h3>

<p>Давайте улучшим наш файервол и настроем на нем трансляцию сетевых адресов.
Настройте форвардинг так, чтобы в пакетах, исходящих из <code>сетей A</code> и <code>B</code>
    при переходе через файервол подменялся адрес источника.
</p>

{{ checkpoint(tasks.forward_nat) }}
{{ check_button("forward_nat") }}
{{ check_log(logs.forward_nat) }}


<p>
    Есть подоздрение, что в <code>сети B</code> кто-то хочет узнать больше о структуре нашей сети.
    Давайте помешаем этим людям, немного модифицировав ICMP пакеты, проходящие через наш файервол из <code>сети B</code> в <code>сеть A</code>.
    Во первых, сделайте так, что TTL всех ICMP пакетов, выходящих из файервола был равен {{ variant.icmp_ttl }}.
    Во вторых, давайте будем терять 25% ICMP пакетов.
</p>

{{ checkpoint(tasks.icmp_config) }}
{{ check_button("icmp_config") }}
{{ check_log(logs.icmp_config) }}

<p>
    В части 2 мы запретили доступ из наших приватных сетей в интернет.
    Давате теперь разрешим из <code>сети A</code> отправлять HTTP и HTTPS запросы на порты 80 и 443 к только одному адресу в интернете, на котором существует сайт <code>nerc.itmo.ru</code>.
</p>

{{ checkpoint(tasks.http_access) }}
{{ check_button("http_access") }}
{{ check_log(logs.http_access) }}

{% endblock %}
